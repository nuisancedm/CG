# 加速光线和大量三角形求交

如果我们对每一根光线和场景中所有的三角形做相交测试，计算量巨大，超级慢。  

## 通过Bounding Volumes加速

Bounding Volumes其实就是包围盒的概念，我们有一个小盒子正正好的把场景中的某一个物体放进去，如果光线连包围盒都无法击中，自然也就无法其中其中的物体，这样就排除一根光线和许多不必要的三角形计算相交性。  
我们通常使用Axis-Aligned Bounding Box (AABB)来当做这个盒子。AABB的面一定是和ZYX面平行的。p'为面上任意一点  
对于AABB来说，计算光线与面相交会很容易，假设我们的面垂直于x平面，那么相交时间t满足
$$
t=\frac {p'_x-o_x}{d_x}
$$

### 光线如何与AABB相交？

* 一个AABB和三对相对的面。  
-- 如果光线同时进入了三个三个对面的夹层，我们就认为光线射进了AABB。  
-- 如果光线离开了某一个夹层，那么就认为光线射出了AABB。
* 对于每一对面，我们计算出光线的射入时间tmin和射出时间tmax (负数不影响)
* 对与AABB，t_enter = max{ t_min }；t_exit = min { t_max }
* 如果t_enter < t_exit， 那么光线在box里待了一段时间，所以就可能有交点。
* 如果t_exit < 0，说明盒子在光源的反方向，不可能有交点。
* 如果t_exit >= 0 && t_enter < 0，说明光源在盒子里，肯定有交点。
* 总结 只有在 t_enter < t_exit && t_exit >= 0，光线与包围盒才有交点。

### Uniform Spatial Partitions(Grid)
  
我们假设光线和盒子求交非常快，光线和物体求交非常慢。  
我们先对光线和盒子求交，如果光线和盒子相交了，再对盒子内的物体求交。  

* 首先，我们找到整个场景的包围盒。  
* 我们把包围盒分成许许多多个格子。  
* 我们把那些内部有物体的格子做一个标记。
* 光纤在行进中射入了内部有物体的格子，做光线与物体的求交，看有没有交点。
* 如果光线和盒子相交，也和物体相交，就找到了一个交点。  

我们划分的格子不能太密集也不能太稀疏，否则效果会很差。

## 通过Spatial Partitions加速

**Oct-Tree**：八叉树划分空间，把空间均匀的递归切成八个小块，并把他们组织成树的结构。  
**KD-Tree**：KD树和八叉树很相似，KD树每一次划分都交替沿着某一个轴切一刀，他的分区结果类似于二叉树。  
**BSP-Tree**: BSP树选择一个方向对空间进行二分，他和KDtree的区别就是BSP树切割的方向不一定沿着轴方向。

### 建立KD-Tree

每一个KD-tree节点存储一下信息：

* 切割轴：x,y,z
* 切割平面在轴方向的坐标
* 指向子节点的指针
* **对于叶子节点**，要额外存储这个节点包含的物体列表。

### 遍历KD-Tree

* 判断光线是否和最大的盒子A相交
* 如果有，我们检测光线是否和A的两个孩子节点是否相交
* ...
* 直到我们遍历到叶节点，和叶子节点中的所有物体求交。

KD树有一个明确的问题，很难求包围盒包含了哪些三角形，而且一个物体可能会被存储在多个叶子节点中，所以KD树也很少用。

## 通过Object Partitions加速

### 建立BVH树

* 首先先对整个场景计算出一个包围盒A。
* 然后我们通过某种方式，把场景中的物体分为两个部分，对这两个部分重新计算包围盒B和C，BC为A的两个子节点。
* ...
* 继续划分，叶节点包含很少的三角形，比如5个。

BVH划分确保了一个物体只会出现在一个节点中。
但是BVH对空间的划分出的包围盒，他们是可以相交的，如何划分这些物体使得包围盒之间重叠最小，是一门学问。

首先找到包围盒最长的那个轴，沿着这个轴找到包围盒中的中位物体切一刀，即两堆物体数量差不多。这个分法涉及到找到一组数中的中位数。在n个数中找第i大的数这个算法可以在O(n)复杂度找到。

### 遍历BVH

``` C++
Intersect(Ray ray, BVH node){
    if(ray misses node.bbox) return ;

    if(node is a leaf node){
        test intersection with all objs;
        return closest intersection;
    }

    hit1 = Intersect(ray, node.child1);
    hit2 = Intersect(ray, node.child2);

    return the closer of hit1 and hit2;
}
```

## 空间划分 vs. 物体划分

空间划分：

* 空间被划分成没有重叠区域包围盒
* 一个物体可能存在于多个区域中

物体划分：

* 一个物体只可能出现在一个区域中
* 包围盒有可能重叠

