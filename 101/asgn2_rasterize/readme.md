# Programs

修改了rasterizer.cpp下的以下两个函数  
void rst::rasterizer::rasterize_triangle(const Triangle& t)  
static bool insideTriangle(float x, float y, const Vector3f*_v)

实现2xMSAA和无MSAA的三角形光栅化

MSAA的黑边问题：  
先理一下光栅化的流程。  
我们需要光栅化两个三角形，这两个三角形是有顺序的，先画绿色的，再画蓝色的。  
我们先单独画出绿色的，此时绿色三角形的边缘部分对绿色三角形和黑色背景进行平均颜色，
所以绿色三角形的边缘会向黑色模糊。  
当画蓝色三角形的时候，蓝色三角形由于z值较远，由于深度检测。蓝色三角形无法修改哪些已经被绿色三角形占用了的像素。所以蓝绿两个三角形重叠的边缘部分仍然是绿色三角形画的偏黑的绿。这就导致了黑边。

而正确的做法是在边缘重叠处将绿色和蓝色混合。

# 视锥  

我们要在空间中定义一个视锥，我们只需要定义两个东西，分别是：  

* 可视角度 FOV
* 宽高比 aspect ratio

有了这两个东西，我们就能用下两个公式计算出视锥内所有的参数。

* tan(FOVY/2) = top / abs(near)
* aspect = right / top  

# 屏幕

屏幕在图形学的概念中是一个**数组**  
这个数组的**长度**是屏幕的**分辨率**  
数组中的每一个成员是一个**像素**  
像素可以抽象的理解成他包含了一个颜色的小方块  
屏幕就是一个**光栅成像设备**  

# 屏幕空间

我们定义屏幕的左下角为坐标轴原点，x轴方向向右，y轴向上  
每一个像素被定义为一个坐标形式(x, y)，并且xy都是整数。  
我们用整数坐标来代表一个像素，但是一个像素的中心位置在(x+0.5，y+0.5)  
整个屏幕空间覆盖了从(0,0)到(width,hight)的所有像素。  

# 从canonical cube到screen space

经过透视投影之后，空间被投影到了一个[-1,1]^3的正方体内部。  
我们想要把这个正方体再转换到屏幕空间中，屏幕空间是一个二维的。  
我们用以下矩阵，完成这个变换，也被称做**视口变换**
[(width/2),0,0,(width/2)],  
[0,(height/2),0,(height/2)],  
[0,0,1,0],  
[0,0,0,1]  
该矩阵只对x，y两个维度进行了变换，把正方体拉伸到符合我们的屏幕空间。  
而z轴保持不变，z轴的值会在之后作为深度值来处理物体之间的遮挡关系。  
这是我们做的最后一步变换，此时还是一堆坐标，这些坐标可以理解为连续的。
想要把这堆坐标转化为真正的屏幕可以显示的图片，我们需要将他离散化。

# 帧缓冲区

我们定义了屏幕为一个数组。现代显示方式中将一块显存映射到这个屏幕上。
这块显存被称为frame buffer(帧缓冲区)  
frame buffer中的数据通常表示为一系列的像素，每个像素包含了定义其颜色和可能的透明度的信息。帧缓冲区是在图像最终显示在屏幕上之前，图形数据暂时存储的地方。

帧缓冲区的大小直接与屏幕分辨率以及颜色深度有关。  
**屏幕分辨率**决定了帧缓冲区需要存储的像素数量，  
而**颜色深度**（每个像素所需的位数）决定了存储每个像素需要多少内存。  
例如，一个分辨率为1920x1080的显示器，每个像素使用24位颜色（8位红色，8位绿色，8位蓝色），那么单个帧缓冲区的大小至少需要：  
1920×1080×24位=1920×1080×3字节 = 6.22MB

# 光栅化

光栅化指将矢量(连续)图形（如3D模型中的顶点和多边形）转换成光栅(离散)图像（像素或点阵图）的过程。这是3D图形渲染管线中的一个关键步骤，负责生成可以在屏幕上显示的二维图像。我们通过**采样**来实现。  
我们用每一个像素中心对屏幕空间进行采样，判断这个像素应该显示什么颜色。
以代码中的判断一个点是否在三角形为例，采样伪代码如下：  

``` C++
for (int x = 0; x < width; x++) {  
    for(int y=0; y < height; y++) {  
        image[x][y] = inside(t, x+0.5, y+0.5) 
    }
}
bool inside (t,x,y){
    bool sign1 = cross(p1Q, p1p2);
    bool sign2 = cross(p2Q, p2p0);
    bool sign3 = cross(p0Q, p0p1);

    if(sign1 == sign2 && sign2 == sign3) return 1

    return 0;
}
```

我们用AABB来优化这一个过程，实际上有一些像素绝对不可能在三角形内。

``` C++
for (int x = 0; x < width; x++) {  
    for(int y=0; y < height; y++) {
        ...
可以修改成AABB形式：
for (int x = minx(p1,p2,p3); x < maxx(p1,p2,p3); x++) {  
    for(int y=miny(p1,p2,p3)0; y < maxy(p1,p2,p3); y++) {
        ...
```

# 抗锯齿/反走样Anti-Aliasing

走样（Aliasing）在计算机图形学和信号处理领域中指的是当一个高频信号以低于其最高频率的采样率被采样时，产生的失真现象。这种现象不仅限于图像，也适用于音频和其他类型的信号。走样的确是由于采样率跟不上信号中的频域变化速度而产生的。

在图形学中，当渲染的图形或纹理中的细节小于像素的大小时，就可能出现走样现象，表现为锯齿状边缘、闪烁或者模糊。这是因为屏幕由有限数量的像素组成，每个像素只能表示一个颜色值，当试图表示一个比单个像素小或接近于像素大小的细节时，就无法准确捕捉到信号的所有信息，导致信息丢失或错误表示。

走样的主要原因包括：

* **空间走样**：在图像渲染中，当高频细节（如细小的文本或尖锐的边缘）被映射到像素网格上时，如果没有足够的分辨率来准确捕获这些细节，就会出现锯齿状的边缘或模糊。这是因为像素网格对连续信号的采样不够密集，无法准确表示信号的所有变化。

* **时间走样**：在动画或视频中，如果帧率太低，无法捕获快速移动对象的连续运动，就会出现运动模糊或跳帧现象。

* **角度走样**：当以斜角显示细长物体（如电话线或远处的栅栏）时，如果物体的宽度小于像素的宽度，就会出现锯齿状边缘。  
  
走样的形成在本质上和采样频率和采样物频率有关。

## 傅里叶变换

傅里叶变换一个函数从时域(空间域)转换到频域(频率域)。
傅里叶变换的核心思想是任何周期函数或信号都可以表示为**简单振荡函数（正弦波和余弦波）的和**。这些振荡函数的频率、振幅和相位是变换的结果，并显示出来，它们描述了原始信号的频率成分。

在相同的采样率下，越低频的信号采样结果越保真，越高频的信号采样结果就越失真，因为采样率跟不上信号变换的频率。

对于一个自然的场景，经过傅里叶变换之后会发现低频信号比高频信号多得多得多。
高频信号通常代表了物体的边界，轮廓等发生突变的地方(这正是锯齿发生的地方)  

## 滤波

滤波指过滤掉某些特定频率的信号，只保留以外的信号。
如果我们在一张图的频率上应用低通滤波，那么就会删除高频的信号，在时域上图片就会删除物体的边界，轮廓等发生突变的地方，视觉上图片就会发生模糊。

滤波 = 卷积  
滤波器也可以被称作卷积核

卷积定理：  
时域上对两个信号进行卷积 = 频域上对两个信号进行乘积  
时域上对两个信号进行乘积 = 频域上对两个信号进行卷积
我们对一张图和一个卷积核进行**卷积**操作，会得到一张模糊之后的图片。  
我们对这张图和这个卷积核经过傅里叶变换后的频域结果进行**乘积**，再**逆傅里叶变换**回时域，会得到一张一模一样的模糊之后的图片。  

卷积核在经过傅里叶变换之后就可以当做一个低通滤波，所以卷积核=滤波器  

## 采样

在**时域**上，采样可以被视为连续信号与一个冲击函数序列（也称为脉冲序列或采样函数）的乘积。这个冲击函数序列由一系列在固定间隔（采样间隔）上的冲击组成，每个冲击代表在该时刻对信号的采样。因此，连续信号与冲击函数序列的乘积实际上“挑选出”了信号在这些冲击时刻的值，可以理解为一个点，这就是采样过程。

在**频域**上，根据傅里叶变换的性质，时域中函数的乘法对应于频域中的卷积。因此，当你在时域中将一个连续信号与一个冲击函数序列相乘时，这等价于在频域中将该信号的频谱与冲击函数序列的频谱进行卷积。冲击函数序列的频谱本身是一系列等间距的冲击，这些**冲击的间隔等于采样频率的倒数**。当原始信号的频谱与这个冲击序列的频谱卷积时，效果相当于在频谱中每隔采样频率的间隔处复制并粘贴原始信号的频谱（时域采样越密集，频域复制越稀疏）。这种现象称为频谱复制或频谱重叠（aliasing），是采样过程的一个固有特性。

为了避免频谱重叠（aliasing），尼奎斯特采样定理指出，采样频率必须至少是信号最高频率成分的两倍，这个最小的采样率被称为尼奎斯特率。如果满足这个条件，原始信号可以从其采样值完全恢复，而频谱重叠可以被避免，但是采样率受限于硬件。

## 如何反走样？

最简单暴力的方法：**增加分辨率/采样率** 1080P有锯齿，就4K，4K不行就8K。这样做纯粹的压榨硬件性能。  
常规方法：**先做模糊，再做采样** 我们拿掉高频信息，再以稀疏采样，就不会发生频谱混叠。

问题就转化成了如何模糊？  
基本思路：对于每个像素，对像素内的颜色和对这个像素的覆盖情况求平均来模糊。

**MSAA：Multi Sampling AntiAliasing 多重采样反走样**
在每个像素内部再进行一次NxN的采样，来求这个像素的平均颜色。  
MSAA只解决了第一步模糊的问题，并没有提升采样率，没有增加分辨率。  
MSAA增加了NxN倍的计算量，如果每个像素都要进行一次2x2采样求平均，就要多出4倍计算量。

**SSAA：Super Sampling AntiAliasing 超采样反走样**  
超采样反走样是一种更为高级且计算密集型的技术，它通过在比最终输出更高的分辨率下渲染图像，然后将图像缩小到目标分辨率来平滑边缘。这种方法可以提供非常高质量的反走样效果，但代价是显著增加的计算需求。

**FXAA：Fast Approximate AntiAliasing 快速近似反走样**  
FXAA和采样率和模糊没有任何关系，他是一种类似后期处理。
通过对最终图像的边缘进行模糊处理来减少锯齿效果。

**TAA：Temporal AntiAliasing**
时间反走样结合了多个连续帧的信息来减少走样，特别是在动态场景中效果显著。它通过对之前帧的信息进行智能混合来平滑当前帧的边缘，可以有效减少锯齿同时保持图像的清晰度。

**Super Resolution/Super Sampling**
超分辨率或者超采样其实不是抗锯齿，他用来提升分辨率。比如我们的采样率只有512x512，但是我们想要1024x1024分辨率的图片，Super Resolution就解决这种问题。  
他和抗锯齿不是一回事，但是他们都是由采样率不足造成的。
比较常见的就是DLSS(Deep Learning Super Sampling)
通过深度学习的方法去猜测哪些缺失的细节。

# Z-buffering 深度缓冲

Zbuffer用来处理多个三角形画在屏幕上之后，来处理他们的之间的遮挡关系(可见性问题)。  

* Painter's Algorithm 画家算法  
和画画的思路一样，按照物体之间远近关系，先画远处的东西，再画近处的东西覆盖远处的东西。
这个算法需要提前知道所有物体的远近关系，需要进行深度排序(O(logn)复杂度)。
且无法处理物体之间互相重叠的情况，局限性太大。

Z-Buffer idea：

* 对于每一个像素，存储一个它看到的最小的z值
* Z-Buffer需要一个额外的显存当做buffer来记录每个像素的深度值。  
使用深度缓冲时，会同时有frame buffer(存储每个像素的颜色)和z buffer(存储深度)。并同时生成渲染图和深度图

为了简单起见，我们认为z永远是正数，z越小越近，z越大越远。  
Zbuffer伪代码(时间复杂度O(n))：

``` C++
for (each triangle T)
    for(each sample(x, y, z) in T)
        if(z < zbuffer[x, y])
            framebuffer[x, y] = rgb;
            zbuffer[x, y];
```
